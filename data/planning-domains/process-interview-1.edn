;;; This is a proj-format structure. See shop.clj.
;;; This example is being used to explore the idea that we can use state information to prune the domain outside of SHOP.
;;; Thus instead of (stop-plan) all over the place, we place editing information into the domain that is used to prune off
;;; parts of the domain that aren't relevant given state.

;;; What I learned (I think!):
;;;  - It is an error (:bad-input) to have a fact that unifies with the head of an axiom! Try this with craft beer and (process-defined craft-beer).

;;; After updating this:
;;; (sutil/register-planning-domain :process-interview (-> "data/planning-domains/process-interview-1.edn" slurp edn/read-string))

{:domain/id :process-interview
 :domain/description "A planning domain to run an interview about the manufacturing processes that are the subject of scheduling"
 :domain/elems [{:method/head (characterize-process ?proj)
                 :method/rhsides [{:method/case-name "from-scratch"
                                   :method/preconds [(proj-id ?proj) (not (ongoing-discussion ?proj))] ; (proj-id ?proj) is needed to unify against (characterize-process ?proj)
                                   :method/task-list [(!initial-question ?proj)
                                                      (discuss-process-detail ?proj)]}

                                  {:method/case-name "ongoing-discussion"
                                   :method/preconds [(ongoing-discussion ?proj)   ; (proj-id ?proj) is needed to unify against (characterize-process ?proj)
                                                     (proj-id ?proj)
                                                     (not (process-defined ?proj))]
                                   :method/task-list [(discuss-process-detail ?proj)
                                                      (!query-process-durs ?proj)
                                                      (!yes-no-process-ordering ?proj)]}]}

                ;; ====== (not (ongoing-discussion ?proj)) ===============================
                ;; (!initial-question ?proj)
                {:operator/head (!initial-question ?proj)
                 :operator/preconds [(not (ongoing-discussion ?proj))]
                 :operator/a-list [(ongoing-discussion ?proj)]}

                ;; ====== (ongoing-discussion ?proj) ===============================
                {:method/head (discuss-process-detail ?proj)
                 :method/rhsides [{:method/case-name "well-known"
                                   :method/preconds [(flow-shop ?proj)]
                                   :method/task-list [(!yes-no-process-steps ?proj)]}
                                  #_{:method/case-name "not-well-known"
                                     :method/preconds [(flow-shop ?proj) (not (well-known-process ?proj))]
                                     :method/task-list [(!query-process-steps ?proj)]}]}

                ;; (!yes-no-process-steps ?proj)
                {:operator/head (!yes-no-process-steps ?proj)
                 :operator/preconds [(proj-id ?proj)]
                 :operator/a-list [(have-process-steps ?proj)]} ; We've arranged so that if you already have all the a-list facts, it runs a no-op.

                ;; (!query-process-steps ?proj)
                {:operator/head (!query-process-steps ?proj)
                 :operator/preconds [(proj-id ?proj) (system-model ?proj flow)]
                 :operator/a-list [(have-process-steps ?proj)]}

                ;; (!query-process-durs ?proj)
                {:operator/head (!query-process-durs ?proj)
                 :operator/preconds [(system-model ?proj flow)]
                 :operator/a-list [(have-process-durs ?proj)]}

                ;; (!yes-no-process-ordering ?proj)
                {:operator/head (!yes-no-process-ordering ?proj)
                 :operator/preconds [#_(well-known-process ?proj) (system-model ?proj flow)]
                 :operator/a-list [(have-process-ordering ?proj)]}

                ;; (!query-process-ordering ?proj)
                #_{:operator/head (!query-process-ordering ?proj)
                 :operator/preconds [(not (well-known-process ?proj)) (system-model ?proj flow)]
                 :operator/a-list [(have-process-ordering ?proj)]}

                ;; (:- (process-defined ?proj)  ; ToDo: Maybe wait until shop disappears, but would like to use process-defined in filtering.
                {:axiom/head (process-defined ?proj)
                 :axiom/rhsides [{:axiom/rhs [(have-process-steps ?proj)
                                              (have-process-ordering ?proj) ; ToDo: This might be solved by whether or not is it 'job-shop' style.
                                              (have-process-durs ?proj)]}]}

                ;; (:- (same ?x ?x) ())
                {:axiom/head (same ?x ?x)}

                ;; (:- (different ?x ?y) ((not (same ?x ?y))))
                {:axiom/head (different ?x ?y)
                 :axiom/rhsides [{:axiom/rhs ((not (same ?x ?y)))}]}]}
